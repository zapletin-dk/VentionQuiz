[
  {
    "question": "Что такое инкапсуляция в ООП?",
    "options": ["Доступ к данным только через методы класса", "Наследование классов", "Создание множества объектов", "Полиморфизм методов"],
    "correctAnswer": "Доступ к данным только через методы класса",
    "theorySnippet": "Инкапсуляция скрывает данные внутри класса, предоставляя доступ только через методы (геттеры/сеттеры) для контроля."
  },
  {
    "question": "Какой модификатор доступа предоставляет наименьшую видимость в Java?",
    "options": ["public", "protected", "private", "default"],
    "correctAnswer": "private",
    "theorySnippet": "Модификатор 'private' ограничивает доступ только внутри класса, обеспечивая максимальную инкапсуляцию."
  },
  {
    "question": "Что такое абстрактный класс в Java?",
    "options": ["Класс, который нельзя инстанцировать напрямую", "Класс с только статическими методами", "Класс без методов", "Класс с приватными полями"],
    "correctAnswer": "Класс, который нельзя инстанцировать напрямую",
    "theorySnippet": "Абстрактный класс используется для определения общей структуры, не создавая объектов напрямую, с помощью 'abstract'."
  },
  {
    "question": "Какой ключевой слово используется для реализации интерфейса в Java?",
    "options": ["extends", "implements", "super", "this"],
    "correctAnswer": "implements",
    "theorySnippet": "'implements' позволяет классу реализовать методы интерфейса, обеспечивая полиморфизм."
  },
  {
    "question": "Что делает ключевое слово 'final' в Java?",
    "options": ["Делает класс неизменяемым", "Запрещает переопределение метода", "Создает постоянную переменную", "Все вышеперечисленное"],
    "correctAnswer": "Все вышеперечисленное",
    "theorySnippet": "'final' фиксирует класс, метод или переменную, предотвращая изменения или переопределение."
  },
  {
    "question": "Какой из следующих принципов ООП относится к использованию одного интерфейса для разных реализаций?",
    "options": ["Инкапсуляция", "Наследование", "Полиморфизм", "Абстракция"],
    "correctAnswer": "Полиморфизм",
    "theorySnippet": "Полиморфизм позволяет использовать один интерфейс для разных реализаций методов в подклассах."
  },
  {
    "question": "Какой метод вызывается автоматически при создании объекта в Java?",
    "options": ["main()", "constructor()", "init()", "finalize()"],
    "correctAnswer": "constructor()",
    "theorySnippet": "Конструктор инициализирует объект при его создании, имея то же имя, что и класс."
  },
  {
    "question": "Что такое перегрузка методов (method overloading) в Java?",
    "options": ["Создание нескольких методов с одинаковыми именами и разными параметрами", "Наследование методов из суперкласса", "Удаление методов из класса", "Переопределение методов в подклассе"],
    "correctAnswer": "Создание нескольких методов с одинаковыми именами и разными параметрами",
    "theorySnippet": "Перегрузка позволяет иметь методы с одинаковым именем, но разным количеством или типом параметров."
  },
  {
    "question": "Какой из следующих типов данных является примитивным в Java?",
    "options": ["String", "Integer", "int", "ArrayList"],
    "correctAnswer": "int",
    "theorySnippet": "Примитивный тип 'int' хранит целые числа, в отличие от объектов, таких как String."
  },
  {
    "question": "Что такое наследование в ООП?",
    "options": ["Создание нового класса на основе существующего", "Скрытие данных внутри класса", "Использование нескольких классов одновременно", "Удаление методов из класса"],
    "correctAnswer": "Создание нового класса на основе существующего",
    "theorySnippet": "Наследование позволяет подклассу унаследовать поля и методы суперкласса с 'extends'."
  },
  {
    "question": "Какой из следующих операторов используется для обработки исключений в Java?",
    "options": ["if", "try", "switch", "for"],
    "correctAnswer": "try",
    "theorySnippet": "'try' используется для блока кода, где могут возникнуть исключения, с последующим 'catch'."
  },
  {
    "question": "Что возвращает метод equals() в Java, если объекты равны?",
    "options": ["true", "false", "null", "1"],
    "correctAnswer": "true",
    "theorySnippet": "Метод equals() сравнивает содержимое объектов, возвращая true при их равенстве."
  },
  {
    "question": "Какой модификатор позволяет доступ к членам класса только в том же пакете?",
    "options": ["public", "protected", "private", "default"],
    "correctAnswer": "default",
    "theorySnippet": "Без указания модификатора (default) доступ ограничен классами в том же пакете."
  },
  {
    "question": "Что такое интерфейс в Java?",
    "options": ["Класс с только абстрактными методами", "Контейнер для объектов", "Метод для обработки исключений", "Тип данных"],
    "correctAnswer": "Класс с только абстрактными методами",
    "theorySnippet": "Интерфейс определяет контракт с абстрактными методами, реализуемыми классами."
  },
  {
    "question": "Что произойдет, если вызвать метод с модификатором 'final' в подклассе?",
    "options": ["Метод будет переопределен", "Скомпилируется ошибка", "Метод будет выполнен как есть", "Класс станет абстрактным"],
    "correctAnswer": "Скомпилируется ошибка",
    "theorySnippet": "'final' предотвращает переопределение метода, вызывая ошибку при попытке."
  },
  {
    "question": "Какая из следующих записей является корректным способом создания объекта в Java?",
    "options": ["Class obj = new Class();", "Class obj = Class.new();", "new Class();", "Class obj;"],
    "correctAnswer": "Class obj = new Class();",
    "theorySnippet": "Создание объекта требует вызова конструктора с 'new' и присваивания переменной."
  },
  {
    "question": "Что такое статический метод в Java?",
    "options": ["Метод, который принадлежит объекту", "Метод, который принадлежит классу", "Метод, который не может быть переопределен", "Метод с приватным доступом"],
    "correctAnswer": "Метод, который принадлежит классу",
    "theorySnippet": "Статический метод вызывается через класс, а не объект, с использованием 'static'."
  },
  {
    "question": "Какой из следующих классов является родителем всех классов в Java?",
    "options": ["Object", "Class", "String", "System"],
    "correctAnswer": "Object",
    "theorySnippet": "Класс Object — базовый для всех классов в Java, предоставляя общие методы."
  },
  {
    "question": "Что делает ключевое слово 'super' в Java?",
    "options": ["Обращается к родительскому классу", "Создает новый объект", "Инициализирует переменную", "Вызывает метод текущего класса"],
    "correctAnswer": "Обращается к родительскому классу",
    "theorySnippet": "'super' используется для вызова методов или конструкторов суперкласса."
  },
  {
    "question": "Какой из следующих циклов используется для итерации по коллекции в Java?",
    "options": ["for", "while", "do-while", "enhanced for"],
    "correctAnswer": "enhanced for",
    "theorySnippet": "Enhanced for (for-each) упрощает итерацию по элементам коллекций и массивов."
  },
  {
    "question": "Что такое переопределение метода (method overriding) в Java?",
    "options": ["Создание метода с тем же именем в подклассе", "Создание метода с разными параметрами", "Удаление метода из класса", "Использование статического метода"],
    "correctAnswer": "Создание метода с тем же именем в подклассе",
    "theorySnippet": "Переопределение позволяет подклассу предоставить свою реализацию метода суперкласса."
  },
  {
    "question": "Какой из следующих типов исключений является проверяемым (checked) в Java?",
    "options": ["NullPointerException", "IOException", "ArrayIndexOutOfBoundsException", "IllegalArgumentException"],
    "correctAnswer": "IOException",
    "theorySnippet": "Checked исключения, как IOException, требуют обработки с try-catch на этапе компиляции."
  },
  {
    "question": "Что возвращает метод length() для строки в Java?",
    "options": ["Количество символов", "Длину в байтах", "Количество слов", "Индекс последнего символа"],
    "correctAnswer": "Количество символов",
    "theorySnippet": "length() возвращает общее число символов в строке, включая пробелы."
  },
  {
    "question": "Какой из следующих является корректным объявлением массива в Java?",
    "options": ["int[] arr = new int[5];", "int arr[] = new int[];", "int[] arr = new int;", "arr[] int = new int[5];"],
    "correctAnswer": "int[] arr = new int[5];",
    "theorySnippet": "Массив объявляется с указанием типа и размера, например, int[] с new int[5]."
  },
  {
    "question": "Что такое конструктор по умолчанию в Java?",
    "options": ["Конструктор без параметров", "Конструктор с приватным доступом", "Конструктор с параметрами", "Статический метод"],
    "correctAnswer": "Конструктор без параметров",
    "theorySnippet": "Конструктор по умолчанию создается автоматически, если не определен другой конструктор."
  },
  {
    "question": "Какой метод используется для преобразования строки в целое число в Java?",
    "options": ["parseInt()", "toInt()", "convertInt()", "stringToInt()"],
    "correctAnswer": "parseInt()",
    "theorySnippet": "parseInt() преобразует строку в int, доступен в классе Integer."
  },
  {
    "question": "Что произойдет, если не обработать исключение в Java?",
    "options": ["Программа завершится с ошибкой", "Исключение будет проигнорировано", "Программа продолжит выполнение", "Исключение будет сохранено"],
    "correctAnswer": "Программа завершится с ошибкой",
    "theorySnippet": "Необработанные исключения приводят к аварийному завершению программы."
  },
  {
    "question": "Какой из следующих является примером полиморфизма в Java?",
    "options": ["Использование интерфейса с разными реализациями", "Создание приватного поля", "Наследование без методов", "Использование статических методов"],
    "correctAnswer": "Использование интерфейса с разными реализациями",
    "theorySnippet": "Полиморфизм реализуется через интерфейсы или абстрактные классы с разными реализациями."
  },
  {
    "question": "Какой из следующих является ключевым словом для создания пакета в Java?",
    "options": ["package", "import", "class", "public"],
    "correctAnswer": "package",
    "theorySnippet": "'package' определяет пространство имен для организации классов в Java."
  },
  {
    "question": "Что такое интерфейс Marker в Java?",
    "options": ["Интерфейс без методов", "Интерфейс с одним методом", "Интерфейс с приватными полями", "Интерфейс с конструктором"],
    "correctAnswer": "Интерфейс без методов",
    "theorySnippet": "Marker интерфейс (например, Serializable) служит флагом без методов."
  },
  {
    "question": "Какой метод используется для получения текущего времени в Java?",
    "options": ["System.currentTimeMillis()", "Time.getCurrent()", "Date.now()", "Clock.current()"],
    "correctAnswer": "System.currentTimeMillis()",
    "theorySnippet": "currentTimeMillis() возвращает время в миллисекундах с эпохи Unix."
  },
  {
    "question": "Что такое Garbage Collection в Java?",
    "options": ["Автоматическое удаление неиспользуемых объектов", "Ручное управление памятью", "Создание новых объектов", "Инициализация памяти"],
    "correctAnswer": "Автоматическое удаление неиспользуемых объектов",
    "theorySnippet": "Garbage Collection автоматически очищает память от неиспользуемых объектов."
  },
  {
    "question": "Какой из следующих является корректным способом объявления интерфейса в Java?",
    "options": ["interface MyInterface {}", "class MyInterface {}", "public MyInterface {}", "interface MyInterface;"],
    "correctAnswer": "interface MyInterface {}",
    "theorySnippet": "Интерфейс объявляется с 'interface' и содержит только абстрактные методы."
  },
  {
    "question": "Что возвращает метод hashCode() в Java?",
    "options": ["Хэш-код объекта", "Размер объекта", "Адрес объекта в памяти", "Количество методов"],
    "correctAnswer": "Хэш-код объекта",
    "theorySnippet": "hashCode() генерирует уникальный код для объекта, используемый в хэш-таблицах."
  },
  {
    "question": "Какой из вариантов не является примером абстракции в ООП?",
    "options": ["Создание абстрактного класса", "Использование приватных полей", "Наследование классов", "Перегрузка методов"],
    "correctAnswer": "Создание абстрактного класса",
    "theorySnippet": "Создание абстрактного класса само по себе не является применением ООП."
  },
  {
  "question": "Какой из следующих интерфейсов используется для итерирования по коллекции в Java?",
  "options": ["Iterator", "Enumerable", "Traversable", "Loopable"],
  "correctAnswer": "Iterator",
  "theorySnippet": "Интерфейс Iterator предоставляет методы hasNext() и next() для безопасного перебора элементов коллекции."
  },
  {
    "question": "Какой метод является корректным способом вызова конструктора суперкласса?",
    "options": ["super();", "parent();", "base();", "superclass();"],
    "correctAnswer": "super();",
    "theorySnippet": "'super()' вызывает конструктор суперкласса, обычно в начале подкласса."
  },
  {
    "question": "Что такое коллекция HashMap в Java?",
    "options": ["Коллекция пар ключ-значение", "Список объектов", "Очередь", "Стек"],
    "correctAnswer": "Коллекция пар ключ-значение",
    "theorySnippet": "HashMap хранит данные в виде пар ключ-значение с быстрой выборкой по ключу."
  },
  {
    "question": "Как можно сравнить объекты двух массивов в Java?",
    "options": ["Использование Arrays.equals()", "Прямое сравнение с == для каждого элемента", "Использование Object.equals() для массивов", "Сравнение с помощью compareTo()"],
    "correctAnswer": "Использование Arrays.equals()",
    "theorySnippet": "Arrays.equals() сравнивает элементы двух массивов поэлементно, возвращая true, если они равны."
  },
  {
    "question": "Что произойдет, если переопределить метод toString() в классе?",
    "options": ["Будет изменено строковое представление объекта", "Метод станет статическим", "Класс станет абстрактным", "Объект удалится"],
    "correctAnswer": "Будет изменено строковое представление объекта",
    "theorySnippet": "toString() определяет строковое представление объекта, часто переопределяется."
  },
  {
    "question": "Для чего каждый класс в Java имеет методы equals() и hashCode()?",
    "options": ["Для сравнения объектов и работы с хэш-таблицами", "Для инициализации объектов", "Для управления потоками", "Для сериализации данных"],
    "correctAnswer": "Для сравнения объектов и работы с хэш-таблицами",
    "theorySnippet": "equals() и hashCode() унаследованы от Object для сравнения объектов и обеспечения корректной работы коллекций, таких как HashMap."
  },
  {
    "question": "Что такое пул строк (String Pool) в Java?",
    "options": ["Область памяти для хранения уникальных строковых литералов", "Коллекция для хранения объектов", "Механизм для создания потоков", "Инструмент для сериализации данных"],
    "correctAnswer": "Область памяти для хранения уникальных строковых литералов",
    "theorySnippet": "String Pool хранит строки из кода в куче, используя интернирование для экономии памяти."
  },
  {
    "question": "Какой из следующих является примером статического импорта в Java?",
    "options": ["import static java.lang.Math.*;", "import java.lang.Math.*;", "static import java.lang.Math;", "import static Math;"],
    "correctAnswer": "import static java.lang.Math*;",
    "theorySnippet": "Статический импорт позволяет использовать методы класса без его имени, как Math.PI."
  },
  {
    "question": "Что такое аннотация @Override в Java?",
    "options": ["Указывает на переопределение метода", "Создает новый метод", "Инициализирует объект", "Определяет интерфейс"],
    "correctAnswer": "Указывает на переопределение метода",
    "theorySnippet": "@Override проверяет, что метод переопределяет метод суперкласса."
  },
  {
    "question": "Какой из следующих является корректным способом обработки нескольких исключений в Java?",
    "options": ["try { ... } catch (Exception e) { ... }", "try { ... } catch (IOException | SQLException e) { ... }", "try { ... } except { ... }", "try { ... } catch (e) { ... }"],
    "correctAnswer": "try { ... } catch (IOException | SQLException e) { ... }",
    "theorySnippet": "Многоуровневый catch с '|' позволяет обработать несколько типов исключений."
  },
  {
    "question": "Что возвращает метод isEmpty() для коллекции в Java?",
    "options": ["true, если коллекция пуста", "Размер коллекции", "Количество элементов", "Тип коллекции"],
    "correctAnswer": "true, если коллекция пуста",
    "theorySnippet": "isEmpty() возвращает true, если коллекция не содержит элементов."
  },
  {
    "question": "Какой из следующих является корректным способом создания enum в Java?",
    "options": ["enum Color { RED, GREEN, BLUE }", "class Color { RED, GREEN, BLUE }", "enum Color (RED, GREEN, BLUE)", "type Color = { RED, GREEN, BLUE }"],
    "correctAnswer": "enum Color { RED, GREEN, BLUE }",
    "theorySnippet": "Enum определяет набор именованных констант, используя ключевое слово 'enum'."
  },
  {
    "question": "Что делает метод clone() в Java?",
    "options": ["Создает копию объекта", "Удаляет объект", "Инициализирует объект", "Запускает поток"],
    "correctAnswer": "Создает копию объекта",
    "theorySnippet": "clone() создает поверхностную копию объекта, если класс реализует Cloneable."
  }
]
